<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nercoeus-blog</title>
    <link>https://nercoeus.github.io/</link>
    <description>Recent content on nercoeus-blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© nercoeus</copyright>
    <lastBuildDate>Fri, 03 Jun 2022 23:31:48 +0800</lastBuildDate><atom:link href="https://nercoeus.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>About</title>
      <link>https://nercoeus.github.io/about/</link>
      <pubDate>Sat, 04 Jun 2022 09:36:52 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/about/</guid>
      <description> github.com twitter email: nercoeus@gmail.com slogan: 靡不有初,鲜克有终 ️  </description>
    </item>
    
    <item>
      <title>CSAPP_1_计算机系统漫游</title>
      <link>https://nercoeus.github.io/post/csapp_1_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</link>
      <pubDate>Fri, 03 Jun 2022 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/csapp_1_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</guid>
      <description>&lt;h2 id=&#34;the-goal-got-this-book-is-to-help-you-underestand-what-happens-and-why-when-you-run-programmer-on-a-system&#34;&gt;The goal got this book is to help you underestand what happens and why when you run programmer on a system.&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>UNP_27_IP选项</title>
      <link>https://nercoeus.github.io/post/unp_27_ip%E9%80%89%E9%A1%B9/</link>
      <pubDate>Fri, 27 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_27_ip%E9%80%89%E9%A1%B9/</guid>
      <description>&lt;h2 id=&#34;271-概述&#34;&gt;27.1 概述&lt;/h2&gt;
&lt;p&gt;  IPv4 允许在 20 字节首部固定部分之后跟最多 40 个字节的选项。尽管已经定义的 IPv4 选项共有 10 种，常用的确实源路径选项。这些选项访问途径是存取 IP_OPTIONS 套接字选项。&lt;br&gt;
  IPv6 允许在固定长度的 40 字节 IPv6 首部和传输层首部之间出现扩展首部。目前定义了 6 种不同的扩展首部。不同于 Ipv4 的是，IPv6 扩展首部的访问途径是函数接口。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UNP_26_线程</title>
      <link>https://nercoeus.github.io/post/unp_26_%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Thu, 26 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_26_%E7%BA%BF%E7%A8%8B/</guid>
      <description>&lt;h1 id=&#34;261-概念&#34;&gt;26.1 概念&lt;/h1&gt;
&lt;p&gt;  在 Unix 上使用 fork 来创建子进程一直以来有一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fork 是昂贵的。fork 要把父进程的内存映像复制到子进程，并在子进程中复制所有描述符，等等。现在的实现是 copy-on-write 技术，用以避免在子进程切实需要自己的副本之前把父进程的数据空间复制到子进程，但是就算如此，fork 依旧是昂贵的。&lt;/li&gt;
&lt;li&gt;fork 返回之后父子进程之间信息的传递需要进程间通信 IPC 机制。调用 fork 之前父进程尚未存在的子进程传递信息相当容易，因为子进程将从父进程数据空间及所有描述符的一个副本开始运行。然而从子进程中返回数据较为繁琐。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>UNP_25_信号驱动式IO</title>
      <link>https://nercoeus.github.io/post/unp_25_%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E5%BC%8Fio/</link>
      <pubDate>Wed, 25 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_25_%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E5%BC%8Fio/</guid>
      <description>&lt;h2 id=&#34;251-概述&#34;&gt;25.1 概述&lt;/h2&gt;
&lt;p&gt;  信号驱动式 I/O 是指进程预先告知内核，使得当某个描述符上发生某事时，内核使用信号通知相关进程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UNP_24_带外数据</title>
      <link>https://nercoeus.github.io/post/unp_24_%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Tue, 24 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_24_%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE/</guid>
      <description>&lt;h2 id=&#34;241-概述&#34;&gt;24.1 概述&lt;/h2&gt;
&lt;p&gt;  许多传输层有带外数据的概念，它有时也称为&lt;strong&gt;经加速数据&lt;/strong&gt;。其想法是一个已连接某端发生重要的事情，而且该端希望迅速通告其对端（也就是比正在缓冲区排队的数据还要快）带外数据的优先级高于普通数据。带外数据不会新建立连接，会被映射到已有连接中。&lt;br&gt;
  UDP 没有办法实现带外数据，所以我们仅仅关心 TCP 的带外数据模型。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UNP_22_高级UDP套接字编程</title>
      <link>https://nercoeus.github.io/post/unp_22_%E9%AB%98%E7%BA%A7udp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sun, 22 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_22_%E9%AB%98%E7%BA%A7udp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;221-概述&#34;&gt;22.1 概述&lt;/h2&gt;
&lt;p&gt;  首先确定某个外来 UDP 数据报的目的地址和接收端口，因为绑定某个 UDP 端口和通配地址的一个套接字能够在任何接口上接受单播，广播和组播数据报。&lt;br&gt;
  TCP 是一个字节流协议，又使用滑动窗口，因此没有记录边界和接收端速度慢于发送端的情况。但是 UDP 却需要程序对这些进行处理。&lt;br&gt;
  如果实现不支持 IP_RECVDSTADDR 套接字选项，那么确定外来 UDP 数据报目的地址的方法之一是捆绑所有接口地址并使用 select。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UNP_21_组播</title>
      <link>https://nercoeus.github.io/post/unp_21_%E7%BB%84%E6%92%AD/</link>
      <pubDate>Sat, 21 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_21_%E7%BB%84%E6%92%AD/</guid>
      <description>&lt;h2 id=&#34;211-概述&#34;&gt;21.1 概述&lt;/h2&gt;
&lt;p&gt;单播地址：单个 IP 接口&lt;br&gt;
组播地址：一组 IP 接口&lt;br&gt;
广播地址：所有 IP 接口（当前局域网中）&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UNP_20_广播</title>
      <link>https://nercoeus.github.io/post/unp_20_%E5%B9%BF%E6%92%AD/</link>
      <pubDate>Fri, 20 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_20_%E5%B9%BF%E6%92%AD/</guid>
      <description>&lt;h2 id=&#34;201-概述&#34;&gt;20.1 概述&lt;/h2&gt;
&lt;h3 id=&#34;emspemspemspemspemspemspemspemspemsp不同类型的寻址方式&#34;&gt;         不同类型的寻址方式&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;IPv4&lt;/th&gt;
&lt;th&gt;IPv6&lt;/th&gt;
&lt;th&gt;TCP&lt;/th&gt;
&lt;th&gt;UDP&lt;/th&gt;
&lt;th&gt;所标识接口数&lt;/th&gt;
&lt;th&gt;递送到接口数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;单播&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;一个&lt;/td&gt;
&lt;td&gt;一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;任播&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;尚没有&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;一组&lt;/td&gt;
&lt;td&gt;一组中的一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;组播&lt;/td&gt;
&lt;td&gt;可选&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;全体&lt;/td&gt;
&lt;td&gt;一组中的全体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;广播&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;全体&lt;/td&gt;
&lt;td&gt;全体&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>UNP_19_密钥管理套接字</title>
      <link>https://nercoeus.github.io/post/unp_19_%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%E5%A5%97%E6%8E%A5%E5%AD%97/</link>
      <pubDate>Thu, 19 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_19_%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%E5%A5%97%E6%8E%A5%E5%AD%97/</guid>
      <description>&lt;h2 id=&#34;191-概述&#34;&gt;19.1 概述&lt;/h2&gt;
&lt;p&gt;  随着 IP 安全体系结构的引入，私钥体系加密和认证密钥的管理越来越需要一套标准的机制。新创建了一套协议族 PF_KEY 域，在这个密钥管理域中，唯一支持的一种套接字是原始套接字。&lt;/p&gt;
&lt;p&gt;  在普通的 Unix 系统上，密钥管理套接字仅限超级用户有打开的权限。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UNP_18_路由套接字</title>
      <link>https://nercoeus.github.io/post/unp_18_%E8%B7%AF%E7%94%B1%E5%A5%97%E6%8E%A5%E5%AD%97/</link>
      <pubDate>Wed, 18 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_18_%E8%B7%AF%E7%94%B1%E5%A5%97%E6%8E%A5%E5%AD%97/</guid>
      <description>&lt;h2 id=&#34;181-概述&#34;&gt;18.1 概述&lt;/h2&gt;
&lt;p&gt;  内核中的 Unix 路由表传统上一直使用 ioctl 命令进行访问，但是没有 ioctl 命令可以获得所有路由表，相反，类似 netstat 等程序通过读取内核的内存获取路由表的内容。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程可以通过写出到路由套接字而往内核发送消息。路径的增加和删除采用这种操作实现&lt;/li&gt;
&lt;li&gt;进程可以通过从路由套接字读入而自内核接收消息。内核采用这种操作通知进程已收到并处理一个 ICMP 重定向消息，或者请求外部路由进程解析一个消息&lt;/li&gt;
&lt;li&gt;进程可以使用 sysctl 函数获取所有路由表或所有已配置的接口&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;前两种操作需要超级用户权限，最后一种只需要普通用户权限&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UNP_17_ioctl操作</title>
      <link>https://nercoeus.github.io/post/unp_17_ioctl%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 17 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_17_ioctl%E6%93%8D%E4%BD%9C/</guid>
      <description>&lt;h2 id=&#34;171-概述&#34;&gt;17.1 概述&lt;/h2&gt;
&lt;p&gt;  ioctl 函数传统上一直作为那些不适合归入其他精细定义类别的特性的系统接口。POSIX 创造了一系列函数用来代替 icotl，但是它还是必不可少的。网络程序经常在程序启动后执行使用 ioctl 获取所在主机全部网络接口的信息：接口地址，是否支持广播，是否支持多播等等&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UNP_16_非阻塞式IO</title>
      <link>https://nercoeus.github.io/post/unp_16_%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8Fio/</link>
      <pubDate>Mon, 16 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_16_%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8Fio/</guid>
      <description>&lt;h2 id=&#34;161-概述&#34;&gt;16.1 概述&lt;/h2&gt;
&lt;p&gt;  套接字的默认状态是阻塞的。这表示发出一个不能立即完成的套接字调用时，其进程会被投入睡眠，等待相应操作完成。可能阻塞的套接字调用可分为下面 4 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入操作，包括 read，readv，recv，recvfrom 和 recvmsg 共 5 个函数。如果某个进程对一个阻塞的 TCP 套接字调用这些输入函数之一，并且缓冲区中没有数据可以读取，进程会进入休眠，知道数据到达。TCP 是字节流协议，该进程的唤醒只要一些数据，如果要设置固定的量，可以使用 readn 或者设置 MSG_WAITALL 标志。对于非阻塞的套接字，如果输入操作不被满足，调用会立即返回一个 EWOULDBLOCK 错误&lt;/li&gt;
&lt;li&gt;输出操作，包括 write，writev，send，sendto 和 sendmsg 共 5 个函数，和输入类似。对于一个非阻塞的 TCP 套接字，如果发送缓冲区没有空间，输出函数调用将立即返回一个 EWOULDBLOCK 错误。&lt;/li&gt;
&lt;li&gt;接受外来连接，即 accept 函数。如果对一个阻塞的套接字调用该 accept 函数，并且没有新的连接到达，调用进程将被投入睡眠。如果一个非阻塞的套接字调用 accept 函数，并且尚无新的连接到达，accept 调用将立即返回一个 EWOLULDBLOCK 错误。&lt;/li&gt;
&lt;li&gt;发起外出连接，即用于 TCP 的 connect 函数。TCP 连接的建立涉及一个三路握手过程，而且 connect 函数一直要等到客户收到对于自己的 SYN 的 ACK 才会返回。这意味着 TCP 的每个 connect 总会阻塞其调用进程至少一个 RTT 时间。如果对一个非阻塞的 TCP 套接字调用 connect，并且连接不能立即建立，那么连接的建立能照样发起，不过会返回一个 EINPROGRESS 错误，注意这个错误和上面的错误并不相同。还需要注意同一主机上的连接会立即建立完成，通常发生在同一主机的情况下。因此对于非阻塞的 connect，我们也要预备 connect 成功返回的情况发生。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>UNP_15_Unix域协议</title>
      <link>https://nercoeus.github.io/post/unp_15_unix%E5%9F%9F%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Sun, 15 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_15_unix%E5%9F%9F%E5%8D%8F%E8%AE%AE/</guid>
      <description>&lt;h2 id=&#34;151-概述&#34;&gt;15.1 概述&lt;/h2&gt;
&lt;p&gt;  Unix 域协议并不是一个实际的协议族，而是在单个主机上执行客户/服务器通信的一种方法。所用 API 就是不同主机通信的 API，Unix 域协议也可以看作 IPC 方法之一。&lt;br&gt;
  Unix 域协议提供两类套接字：字节流套接字（类似 TCP）和数据报套接字（类似 UDP）&lt;br&gt;
使用 Unix 域协议的原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同主机使用 Unix 域协议性能比普通 TCP 套接字快出一倍&lt;/li&gt;
&lt;li&gt;Unix 域套接字可用于同一主机上的不同进程之间传递描述符&lt;/li&gt;
&lt;li&gt;Unix 域套接字新的实现把客户的凭证提供给服务器，这样可以提供额外的安全措施检查&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>UNP_14_高级IO函数</title>
      <link>https://nercoeus.github.io/post/unp_14_%E9%AB%98%E7%BA%A7io%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 14 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_14_%E9%AB%98%E7%BA%A7io%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;h2 id=&#34;141-概述&#34;&gt;14.1 概述&lt;/h2&gt;
&lt;p&gt;  本章讨论 I/O 的高级操作，首先是在 I/O 上设置超时，这里有三种方法。然后是 read 和 write 的三个变体：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;recv 和 send 允许通过第四个参数从进程到内核传递标志&lt;/li&gt;
&lt;li&gt;readv 和 writev 允许指定往其中输入数据或从其中输出数据的缓冲区向量&lt;/li&gt;
&lt;li&gt;recvmsg 和 sendmsg 结合了其他 I/O 函数的所有特性，并具备接收和发送辅助数据的新能力&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>UNP_13_守护进程和inetd超级服务器</title>
      <link>https://nercoeus.github.io/post/unp_13_%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%92%8Cinetd%E8%B6%85%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Fri, 13 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_13_%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%92%8Cinetd%E8%B6%85%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>&lt;h2 id=&#34;131-概述&#34;&gt;13.1 概述&lt;/h2&gt;
&lt;p&gt;  &lt;strong&gt;守护进程&lt;/strong&gt;：是在后台运行且不与任何控制终端关联的进程。Unix 系统通常有很多守护进程在后台运行（20~50）执行不同的管理任务&lt;br&gt;
  守护进程没有终端，通常是因为他们由开机时的脚本进行启动。但是守护进程也可能从某个终端由用户在 shell 提示符下键入命令行进行启动，这样的守护进程必须亲自脱离与控制终端的关联，从而避免与作业控制，终端会话管理，终端产生信号等发生不希望的交互,也防止后台的守护进程输出到终端&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UNP_12_IPv4和IPv6的互操作性</title>
      <link>https://nercoeus.github.io/post/unp_12_ipv4%E5%92%8Cipv6%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7/</link>
      <pubDate>Thu, 12 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_12_ipv4%E5%92%8Cipv6%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7/</guid>
      <description>&lt;h2 id=&#34;121-概述&#34;&gt;12.1 概述&lt;/h2&gt;
&lt;p&gt;  未来，因特网会逐渐从 IPv4 转换到 IPv6，所以引用程序能够对两种协议协同工作是很重要的，我们将讨论 IPv4 应用如何与 IPv6 进行通信&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UNP_8_基本UDP套接字编程</title>
      <link>https://nercoeus.github.io/post/unp_8_%E5%9F%BA%E6%9C%ACudp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sun, 08 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_8_%E5%9F%BA%E6%9C%ACudp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;81-概述&#34;&gt;8.1 概述&lt;/h2&gt;
&lt;p&gt;  在使用 TCP 编写的程序和 UDP 编写的程序之间存在本质的差别，这两种协议的传输层存在差别：UDP 是无连接不可靠的数据报协议，不同于 TCP 提供的面向连接的可靠字节流。相比 TCP 有些场合更加适合使用 UDP,例如 DNS，NFS，SNMP系统等等&lt;/p&gt;
&lt;p&gt;  客户和服务器之间的数据传输可以使用  sendto，recvfrom 两个函数来进行通讯，其中，sendto 必须指定目的地址，同理 recvfrom 会一并收到客户端的协议地址，所以服务器可以正确的对客户端进行响应&lt;/p&gt;
&lt;p&gt;  本章还会介绍在 UDP 协议中使用 connect 的影响&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UNP_7_套接字选项</title>
      <link>https://nercoeus.github.io/post/unp_7_%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9/</link>
      <pubDate>Sat, 07 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_7_%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9/</guid>
      <description>&lt;h2 id=&#34;71-概述&#34;&gt;7.1 概述&lt;/h2&gt;
&lt;p&gt;  有很多方法来获取和设置影响套接字的选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;getsockopt() 和 setsockopt() 函数&lt;/li&gt;
&lt;li&gt;fcntl() 函数&lt;/li&gt;
&lt;li&gt;ioctl() 函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  fcntl 函数是把套接字设置为非阻塞式 I/O 型或信号驱动式 I/O 型以及设置套接字的方法&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UNP_6_IO复用</title>
      <link>https://nercoeus.github.io/post/unp_6_io%E5%A4%8D%E7%94%A8select%E5%92%8Cpoll%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 06 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_6_io%E5%A4%8D%E7%94%A8select%E5%92%8Cpoll%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;h2 id=&#34;61-概述&#34;&gt;6.1 概述&lt;/h2&gt;
&lt;p&gt;  上一章的问题在于TCP客户端同时处理两个套接字，标准输入和TCP套接字。在客户阻塞于fgets调用期间，服务器进程会被杀死。服务器TCP虽然正确的给客户TCP发送了一个FIN，但是客户进程既然阻塞于标准输入读入的过程，他将看不到这个EOF。这样的进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个I/O条件接续，就通知进程，这被称为IO复用&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UNP_5_TCP客户&amp;服务器程序示例</title>
      <link>https://nercoeus.github.io/post/unp_5_tcp%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Thu, 05 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_5_tcp%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B/</guid>
      <description>&lt;h2 id=&#34;51-概述&#34;&gt;5.1 概述&lt;/h2&gt;
&lt;p&gt;  本章使用上一章的函数来编写一个完整的 TCP 客户端服务器端的程序示例（回射服务器）&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UNP_4_基本TCP套接字编程</title>
      <link>https://nercoeus.github.io/post/unp_4_%E5%9F%BA%E6%9C%ACtcp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 04 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_4_%E5%9F%BA%E6%9C%ACtcp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;41-概述&#34;&gt;4.1 概述&lt;/h2&gt;
&lt;p&gt;  本章编写完整的TCP客户、服务程序所需要的套接字函数，并编写程序。同样包括并发服务器，通过派生子进程来处理新的连接&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UNP_3_套接字编程简介</title>
      <link>https://nercoeus.github.io/post/unp_3_%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 03 Mar 2020 23:31:48 +0800</pubDate>
      
      <guid>https://nercoeus.github.io/post/unp_3_%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;套接字编程简介&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>go源码阅读_Channel</title>
      <link>https://nercoeus.github.io/post/go%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB_channel/</link>
      <pubDate>Mon, 13 Jan 2020 18:42:22 +0000</pubDate>
      
      <guid>https://nercoeus.github.io/post/go%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB_channel/</guid>
      <description>&lt;p&gt;  最近代码中出现了一个十分诡异的 bug,找了半天才发现原来是因为 channel 的使用不当所导的.channel 有一个特性是读一个有缓冲区且已关闭的 channel 时,会一直返回默认值.可能是 0,&amp;quot;&amp;quot;,或 nil,因为我使用了一个 for{select &amp;lt;-message}直接导致程序无限触发.要想更好的使用 channel 我们需要了解它内部的实现原理,下面就一起看看 channel 的实现.因为网上关于 channel 的文章十分之多,所以这里主要做的还是个人学习总结的为主.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
