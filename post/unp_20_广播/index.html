<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>UNP_20_广播 - nercoeus-blog</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="20.1 概述
         不同类型的寻址方式



类型
IPv4
IPv6
TCP
UDP
所标识接口数
递送到接口数




单播
√
√
√
√
一个
一个


任播

√
尚没有
√
一组
一组中的一个


组播
可选
√

√
全体
一组中的全体


广播
√


√
全体
全体


" />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="UNP_20_广播" />
<meta property="og:description" content="20.1 概述
         不同类型的寻址方式



类型
IPv4
IPv6
TCP
UDP
所标识接口数
递送到接口数




单播
√
√
√
√
一个
一个


任播

√
尚没有
√
一组
一组中的一个


组播
可选
√

√
全体
一组中的全体


广播
√


√
全体
全体


" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://nercoeus.github.io/post/unp_20_%E5%B9%BF%E6%92%AD/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-03-20T23:31:48&#43;08:00" />
<meta property="article:modified_time" content="2020-03-20T23:31:48&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="UNP_20_广播"/>
<meta name="twitter:description" content="20.1 概述
         不同类型的寻址方式



类型
IPv4
IPv6
TCP
UDP
所标识接口数
递送到接口数




单播
√
√
√
√
一个
一个


任播

√
尚没有
√
一组
一组中的一个


组播
可选
√

√
全体
一组中的全体


广播
√


√
全体
全体


"/>
<script src="https://nercoeus.github.io/js/feather.min.js"></script>
	
	
        <link href="https://nercoeus.github.io/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://nercoeus.github.io/css/main.40ca3a860425083862b7ebd55447caec5c4384573f0cb098b8d06a91e8dace2e.css" />
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://nercoeus.github.io/">nercoeus-blog</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/post">All posts</a>
		
		<a href="/about">About</a>
		
		<a href="/tags">Tags</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">UNP_20_广播</h1>
			<div class="meta">Posted on Mar 20, 2020</div>
		</div>
		

		<section class="body">
			<h2 id="201-概述">20.1 概述</h2>
<h3 id="emspemspemspemspemspemspemspemspemsp不同类型的寻址方式">         不同类型的寻址方式</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>IPv4</th>
<th>IPv6</th>
<th>TCP</th>
<th>UDP</th>
<th>所标识接口数</th>
<th>递送到接口数</th>
</tr>
</thead>
<tbody>
<tr>
<td>单播</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>一个</td>
<td>一个</td>
</tr>
<tr>
<td>任播</td>
<td></td>
<td>√</td>
<td>尚没有</td>
<td>√</td>
<td>一组</td>
<td>一组中的一个</td>
</tr>
<tr>
<td>组播</td>
<td>可选</td>
<td>√</td>
<td></td>
<td>√</td>
<td>全体</td>
<td>一组中的全体</td>
</tr>
<tr>
<td>广播</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td>全体</td>
<td>全体</td>
</tr>
</tbody>
</table>
<ul>
<li>组播支持在 IPv4 中是可选的，在 IPv6 中却是必须的</li>
<li>IPv6 不支持广播。任何使用 IPv4 编写的广播程序，在移植到 IPV6 上要换成组播</li>
<li>广播和组播要求用于 UDP 或原始 IP，他们不能用于 TCP</li>
</ul>
<p>  IPv6 往寻址体系结构中增加了任播方式。任播允许从一组通常提供相同服务的主机中选择一个（一般是最近的一个）通过适当的配置路由，并在多个位置往路由协议中注入同一个地址，多个 IPv4 或 IPv6 主机可以提供该地址的任播服务，任播还在逐步地完善中。<br>
  广播的用途之一是在本地子网定位一个服务器主机，前提是已经知道这台服务器主机位于本地子网，但并不知道具体的单播地址。这种操作也称为 <strong>资源发现</strong> 。另一个用途是在有多个客户端与单个服务器主机通信的局域网环境中尽量减少分组流通。处于这个目的使用广播的因特网应用有多个例子：</p>
<ul>
<li>ARP：ARP 并不是一个用户应用，而是 IPv4 的基本组成之一。ARP 在本地子网上广播一个请获取想要的硬件地址。ARP 使用在链路层不是 IP 层</li>
<li>DHCP：在认定本地子网存在一个 DHCP 服务器主机的前提下，DCHP 客户主机向广播地址（通常是 255.255.255.255）发送自己的请求</li>
<li>NTP：NTR 的一种常见使用情形是客户主机配置上待使用的一个或多个服务器主机的 IP 地址，然后以某个频度轮询这些服务器主机。根据由服务器返回的当前时间和到达服务器的 RTT，客户使用更精妙的算法更新本地时钟</li>
<li>路由守护进程：route 是最早实现且常用的路由守护进程之一，它在一个局域网上广播自己的路由表。这样一来该局域网所有路由器都可以接受这些路由通告，而无须事先为每个路由器配置其邻居路由的 IP 地址</li>
</ul>
<p><strong>组播可以代替广播的这两个用途（资源发现、减少网络分组流通）广播有一定的问题</strong></p>
<h2 id="202-广播地址">20.2 广播地址</h2>
<p>广播地址例子：</p>
<ul>
<li>子网 192.168.42/24 的所有接口的子网定向广播地址是 192.168.42.255 {子网 ID，-1}</li>
<li>受限广播地址 {-1， -1} 或 255.255.255.255</li>
</ul>
<p><strong>路由器从不转发目的地址为 255.255.255.255 的 IP 数据报</strong></p>
<h2 id="203-单播和广播的比较">20.3 单播和广播的比较</h2>
<p>  单播局域网中其余的主机可以在比较了自己的以太网地址和数据报的目标以太网地址，发现不同就会忽略，只有相同才会沿着协议栈对其进行处理。所以忽略它的是接口而不是主机。但是对于广播，局域网中的所有主机都会对其沿着协议栈进行处理，所以忽略它的是主机<br>
  广播存在的问题是：子网上未参与相应广播的所有主机也不得不沿协议栈一路向上完整的处理收取的 UDP 广播数据报，直到该数据报在 UDP 层时被丢弃。另外，子网所有非 IP 主机也不得不在数据链路层接受完整的帧，然后再丢弃它。如果又较高速率产生 IP 广播数据报，可能会严重影响子网其余主机的性能，使用组播来解决这个问题。</p>
<h2 id="204-使用广播的-dg_cli-函数">20.4 使用广播的 dg_cli 函数</h2>
<p>修改 dg_cli 函数，使得可以向 UDP 标准 daytime 服务器广播发送请求，然后显示所有应答</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dg_cli</span>(FILE <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">int</span> sockfd, <span style="color:#66d9ef">const</span> SA <span style="color:#f92672">*</span>pservaddr, socklen_t servlen)
{
	<span style="color:#66d9ef">int</span>				n;
	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span>		on <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">char</span>			sendline[MAXLINE], recvline[MAXLINE <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
	socklen_t		len;
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span>	<span style="color:#f92672">*</span>preply_addr;
    <span style="color:#75715e">// 给 recvfrom 收到的服务器地址分配空间
</span><span style="color:#75715e"></span>	preply_addr <span style="color:#f92672">=</span> Malloc(servlen);
    <span style="color:#75715e">// 设置 SO_BROADCAST 套接字选项
</span><span style="color:#75715e"></span>	Setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, <span style="color:#f92672">&amp;</span>on, <span style="color:#66d9ef">sizeof</span>(on));
    <span style="color:#75715e">// 设置 SIGALRM 的信号处理函数 recvfrom_alarm
</span><span style="color:#75715e"></span>	Signal(SIGALRM, recvfrom_alarm);
    <span style="color:#75715e">// 下面发送的是广播数据报，可能会获得多个应答，我们在一个循环中调用 recvfrom，并显示在 5 秒钟内收到应答
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 5 秒后系统会产生 SIGLARM 信号，导致 recvfrom 返回 EINTR 错误
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (Fgets(sendline, MAXLINE, fp) <span style="color:#f92672">!=</span> NULL) {

		Sendto(sockfd, sendline, strlen(sendline), <span style="color:#ae81ff">0</span>, pservaddr, servlen);

		alarm(<span style="color:#ae81ff">5</span>);
		<span style="color:#66d9ef">for</span> ( ; ; ) {
			len <span style="color:#f92672">=</span> servlen;
			n <span style="color:#f92672">=</span> recvfrom(sockfd, recvline, MAXLINE, <span style="color:#ae81ff">0</span>, preply_addr, <span style="color:#f92672">&amp;</span>len);
			<span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
				<span style="color:#66d9ef">if</span> (errno <span style="color:#f92672">==</span> EINTR)
					<span style="color:#66d9ef">break</span>;		<span style="color:#75715e">/* waited long enough for replies */</span>
				<span style="color:#66d9ef">else</span>
					err_sys(<span style="color:#e6db74">&#34;recvfrom error&#34;</span>);
			} <span style="color:#66d9ef">else</span> {
                <span style="color:#75715e">// 打印收到的回答
</span><span style="color:#75715e"></span>				recvline[n] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;	<span style="color:#75715e">/* null terminate */</span>
				printf(<span style="color:#e6db74">&#34;from %s: %s&#34;</span>,
						Sock_ntop_host(preply_addr, len), recvline);
			}
		}
	}
	free(preply_addr);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">recvfrom_alarm</span>(<span style="color:#66d9ef">int</span> signo)
{
	<span style="color:#66d9ef">return</span>;		<span style="color:#75715e">/* just interrupt the recvfrom() */</span>
}
</code></pre></div><p>  内核不允许对广播数据报进行分片，对于目的地址是广播地址的 IP 数据报，如果其大小超过外出接口 MTU 会返回 EMSGSIZE 错误。原因可能是广播已经给网络造成很大压力，再进行分片，局域网的压力会大大增加。</p>
<h2 id="205-竞争状态">20.5 竞争状态</h2>
<p>  对于上一小节的代码，其中存在着一个问题：我们在一个无限 for 循环处理打印程序，通过定时闹钟来 break。但是问题是在 for 循环的任何时候都可能执行信号处理，并不仅仅是我们期望的在 recvfrom 阻塞中进行。所以当正在打印时执行信号处理操作，我们就一直会阻塞在 recvfrom 上了，因为我们唯一可以通过信号处理在 recvfrom 上跳出循环的机会让我们错失在了打印时。</p>
<p>下面有 4 种解决办法，第一种是错误的：</p>
<h3 id="1阻塞和解阻塞信号错误版本">1.阻塞和解阻塞信号（错误版本）：</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dg_cli</span>(FILE <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">int</span> sockfd, <span style="color:#66d9ef">const</span> SA <span style="color:#f92672">*</span>pservaddr, socklen_t servlen)
{
	<span style="color:#66d9ef">int</span>				n;
	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span>		on <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">char</span>			sendline[MAXLINE], recvline[MAXLINE <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
	sigset_t		sigset_alrm;
	socklen_t		len;
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span>	<span style="color:#f92672">*</span>preply_addr;
 
	preply_addr <span style="color:#f92672">=</span> Malloc(servlen);

	Setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, <span style="color:#f92672">&amp;</span>on, <span style="color:#66d9ef">sizeof</span>(on));
    <span style="color:#75715e">// 声明一个信号集，把它初始化为空集，再打开 SIGALRM 对应的位
</span><span style="color:#75715e"></span>	Sigemptyset(<span style="color:#f92672">&amp;</span>sigset_alrm);
	Sigaddset(<span style="color:#f92672">&amp;</span>sigset_alrm, SIGALRM);

	Signal(SIGALRM, recvfrom_alarm);

	<span style="color:#66d9ef">while</span> (Fgets(sendline, MAXLINE, fp) <span style="color:#f92672">!=</span> NULL) {

		Sendto(sockfd, sendline, strlen(sendline), <span style="color:#ae81ff">0</span>, pservaddr, servlen);

		alarm(<span style="color:#ae81ff">5</span>);
		<span style="color:#66d9ef">for</span> ( ; ; ) {
            <span style="color:#75715e">// 调用 recvfrom 前，解阻塞 SIGALRM 信号
</span><span style="color:#75715e"></span>			len <span style="color:#f92672">=</span> servlen;
			Sigprocmask(SIG_UNBLOCK, <span style="color:#f92672">&amp;</span>sigset_alrm, NULL);
			n <span style="color:#f92672">=</span> recvfrom(sockfd, recvline, MAXLINE, <span style="color:#ae81ff">0</span>, preply_addr, <span style="color:#f92672">&amp;</span>len);
            <span style="color:#75715e">// recvfrom 函数结束后，立即阻塞 SIGALRM 信号，直到等到下一次解阻塞，也就是下一次循环开始
</span><span style="color:#75715e"></span>			Sigprocmask(SIG_BLOCK, <span style="color:#f92672">&amp;</span>sigset_alrm, NULL);
			<span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
				<span style="color:#66d9ef">if</span> (errno <span style="color:#f92672">==</span> EINTR)
					<span style="color:#66d9ef">break</span>;		<span style="color:#75715e">/* waited long enough for replies */</span>
				<span style="color:#66d9ef">else</span>
					err_sys(<span style="color:#e6db74">&#34;recvfrom error&#34;</span>);
			} <span style="color:#66d9ef">else</span> {
				recvline[n] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;	<span style="color:#75715e">/* null terminate */</span>
				printf(<span style="color:#e6db74">&#34;from %s: %s&#34;</span>,
						Sock_ntop_host(preply_addr, len), recvline);
			}
		}
	}
	free(preply_addr);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> 
<span style="color:#a6e22e">recvfrom_alarm</span>(<span style="color:#66d9ef">int</span> signo)
{
	<span style="color:#66d9ef">return</span>;		<span style="color:#75715e">/* just interrupt the recvfrom() */</span>
}
</code></pre></div><p>  这种方式仍然存在问题，就是 recvfrom 和 阻塞 SIGALRM 信号操作都是相互独立的操作，万一，信号在 recvfrom 调用完但是信号还没有阻塞之前进行递交，那么内核就不能阻塞该信号，虽然出错拆给你扣已经很小了，但是问题依然是存在的。</p>
<h3 id="2用-pselect-阻塞和解阻塞信号">2.用 pselect 阻塞和解阻塞信号：</h3>
<p>使用 pselect 来解决这个问题：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dg_cli</span>(FILE <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">int</span> sockfd, <span style="color:#66d9ef">const</span> SA <span style="color:#f92672">*</span>pservaddr, socklen_t servlen)
{
	<span style="color:#66d9ef">int</span>				n;
	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span>		on <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">char</span>			sendline[MAXLINE], recvline[MAXLINE <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
	fd_set			rset;
	sigset_t		sigset_alrm, sigset_empty;
	socklen_t		len;
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span>	<span style="color:#f92672">*</span>preply_addr;
 
	preply_addr <span style="color:#f92672">=</span> Malloc(servlen);

	Setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, <span style="color:#f92672">&amp;</span>on, <span style="color:#66d9ef">sizeof</span>(on));

	FD_ZERO(<span style="color:#f92672">&amp;</span>rset);

	Sigemptyset(<span style="color:#f92672">&amp;</span>sigset_empty);
	Sigemptyset(<span style="color:#f92672">&amp;</span>sigset_alrm);
	Sigaddset(<span style="color:#f92672">&amp;</span>sigset_alrm, SIGALRM);

	Signal(SIGALRM, recvfrom_alarm);

	<span style="color:#66d9ef">while</span> (Fgets(sendline, MAXLINE, fp) <span style="color:#f92672">!=</span> NULL) {
		Sendto(sockfd, sendline, strlen(sendline), <span style="color:#ae81ff">0</span>, pservaddr, servlen);
        <span style="color:#75715e">// 阻塞 SIGALRM 并调用 pselect
</span><span style="color:#75715e"></span>		Sigprocmask(SIG_BLOCK, <span style="color:#f92672">&amp;</span>sigset_alrm, NULL);
		alarm(<span style="color:#ae81ff">5</span>);
		<span style="color:#66d9ef">for</span> ( ; ; ) {
			FD_SET(sockfd, <span style="color:#f92672">&amp;</span>rset);
            <span style="color:#75715e">// 调用 pselect 时，信号都是非阻塞的。调用完成，再恢复成被调用时的状态
</span><span style="color:#75715e"></span>			n <span style="color:#f92672">=</span> pselect(sockfd<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>rset, NULL, NULL, NULL, <span style="color:#f92672">&amp;</span>sigset_empty);
			<span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
				<span style="color:#66d9ef">if</span> (errno <span style="color:#f92672">==</span> EINTR)
					<span style="color:#66d9ef">break</span>;
				<span style="color:#66d9ef">else</span>
					err_sys(<span style="color:#e6db74">&#34;pselect error&#34;</span>);
			} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>)
				err_sys(<span style="color:#e6db74">&#34;pselect error: returned %d&#34;</span>, n);
            <span style="color:#75715e">// 套接字变为可读，直接调用 recvfrom
</span><span style="color:#75715e"></span>			len <span style="color:#f92672">=</span> servlen;
			n <span style="color:#f92672">=</span> Recvfrom(sockfd, recvline, MAXLINE, <span style="color:#ae81ff">0</span>, preply_addr, <span style="color:#f92672">&amp;</span>len);
			recvline[n] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;	<span style="color:#75715e">/* null terminate */</span>
			printf(<span style="color:#e6db74">&#34;from %s: %s&#34;</span>,
					Sock_ntop_host(preply_addr, len), recvline);
		}
	}
	free(preply_addr);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">recvfrom_alarm</span>(<span style="color:#66d9ef">int</span> signo)
{
	<span style="color:#66d9ef">return</span>;		<span style="color:#75715e">/* just interrupt the recvfrom() */</span>
}
</code></pre></div><h3 id="3使用-sigsetjmp-和-siglongjmp">3.使用 sigsetjmp 和 siglongjmp：</h3>
<p>  解决静态问题还可以不使用信号来进行中断被阻塞系统调用并跳出循环。在是在信号处理函数中调用 siglongjmp 函数，siglongjmp 是非局部跳转，使用它可以从一个函数跳转到另一个函数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>			<span style="color:#a6e22e">recvfrom_alarm</span>(<span style="color:#66d9ef">int</span>);
<span style="color:#75715e">// 本函数和信号处理函数使用的跳转缓冲区
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> sigjmp_buf	jmpbuf;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dg_cli</span>(FILE <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">int</span> sockfd, <span style="color:#66d9ef">const</span> SA <span style="color:#f92672">*</span>pservaddr, socklen_t servlen)
{
	<span style="color:#66d9ef">int</span>				n;
	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span>		on <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">char</span>			sendline[MAXLINE], recvline[MAXLINE <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
	socklen_t		len;
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span>	<span style="color:#f92672">*</span>preply_addr;
 
	preply_addr <span style="color:#f92672">=</span> Malloc(servlen);

	Setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, <span style="color:#f92672">&amp;</span>on, <span style="color:#66d9ef">sizeof</span>(on));

	Signal(SIGALRM, recvfrom_alarm);

	<span style="color:#66d9ef">while</span> (Fgets(sendline, MAXLINE, fp) <span style="color:#f92672">!=</span> NULL) {

		Sendto(sockfd, sendline, strlen(sendline), <span style="color:#ae81ff">0</span>, pservaddr, servlen);

		alarm(<span style="color:#ae81ff">5</span>);
		<span style="color:#66d9ef">for</span> ( ; ; ) {
            <span style="color:#75715e">// 从 dg_cli 函数中直接调用 sigsetjmp 时，它在建立跳转缓冲区后返回 0，接着调用 recvfrom。
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (sigsetjmp(jmpbuf, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
				<span style="color:#66d9ef">break</span>;
			len <span style="color:#f92672">=</span> servlen;
			n <span style="color:#f92672">=</span> Recvfrom(sockfd, recvline, MAXLINE, <span style="color:#ae81ff">0</span>, preply_addr, <span style="color:#f92672">&amp;</span>len);
			recvline[n] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;	<span style="color:#75715e">/* null terminate */</span>
			printf(<span style="color:#e6db74">&#34;from %s: %s&#34;</span>,
					Sock_ntop_host(preply_addr, len), recvline);
		}
	}
	free(preply_addr);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">recvfrom_alarm</span>(<span style="color:#66d9ef">int</span> signo)
{
    <span style="color:#75715e">// 调用 siglongjmp 使 dg_cli 进行跳转
</span><span style="color:#75715e"></span>	siglongjmp(jmpbuf, <span style="color:#ae81ff">1</span>);
}
</code></pre></div><h3 id="4使用从信号处理函数到主控函数的-ipc">4.使用从信号处理函数到主控函数的 IPC：</h3>
<p>  通过信号通知系统 IPC 再通过 IPC 管道通知 dg_cli 中循环跳出，这里不贴代码了</p>
<h2 id="小结">小结</h2>
<p>  广播发送的数据报由子网上所有终端主机接收。广播的劣势在于同一个子网上所有主机都必须处理数据报，若是 UDP 数据报则需要沿着协议栈一直处理到 UDP 层，即使不参与广播也需要处理，运行大量广播的应用，系统负担较大。使用组播解决这个问题，因为组播发送的数据只会对相应组播应用感兴趣的主机接收处理。</p>
<p> 解决竞争状态的几种方式：</p>
<ul>
<li>使用 pselect</li>
<li>使用 sigsetjmp 和 siglongjmp</li>
<li>使用从信号处理函数到主循环的 IPC（典型为管道）</li>
</ul>
		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/unp-book-notes">UNP-book-notes</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/nercoeus" title="GitHub"><i data-feather="github"></i></a><a class="soc" href="https://twitter.com/nercoeus/" title="Twitter"><i data-feather="twitter"></i></a><a class="soc" href="nercoeus@gmail.com" title="Email"><i data-feather="mail"></i></a></div>
  <div class="footer-info">
    2022  © nercoeus |  Built with <a
      href="https://gohugo.io">Hugo</a>
  </div>
</footer>


<script>
  feather.replace()
</script></div>
    </body>
</html>
