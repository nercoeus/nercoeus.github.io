<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go源码 on nercoeus-blog</title>
    <link>https://nercoeus.github.io/categories/go%E6%BA%90%E7%A0%81/</link>
    <description>Recent content in go源码 on nercoeus-blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© nercoeus</copyright>
    <lastBuildDate>Mon, 13 Jan 2020 18:42:22 +0000</lastBuildDate><atom:link href="https://nercoeus.github.io/categories/go%E6%BA%90%E7%A0%81/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>go源码阅读_Channel</title>
      <link>https://nercoeus.github.io/post/go%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB_channel/</link>
      <pubDate>Mon, 13 Jan 2020 18:42:22 +0000</pubDate>
      
      <guid>https://nercoeus.github.io/post/go%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB_channel/</guid>
      <description>&lt;p&gt;  最近代码中出现了一个十分诡异的 bug,找了半天才发现原来是因为 channel 的使用不当所导的.channel 有一个特性是读一个有缓冲区且已关闭的 channel 时,会一直返回默认值.可能是 0,&amp;quot;&amp;quot;,或 nil,因为我使用了一个 for{select &amp;lt;-message}直接导致程序无限触发.要想更好的使用 channel 我们需要了解它内部的实现原理,下面就一起看看 channel 的实现.因为网上关于 channel 的文章十分之多,所以这里主要做的还是个人学习总结的为主.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
