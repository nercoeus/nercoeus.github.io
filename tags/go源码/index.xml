<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go源码 on nercoeus-blog</title>
    <link>https://nercoeus.github.io/tags/go%E6%BA%90%E7%A0%81/</link>
    <description>Recent content in go源码 on nercoeus-blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© nercoeus</copyright>
    <lastBuildDate>Mon, 13 Jan 2020 18:42:22 +0000</lastBuildDate><atom:link href="https://nercoeus.github.io/tags/go%E6%BA%90%E7%A0%81/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>go源码阅读_Channel</title>
      <link>https://nercoeus.github.io/post/go%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB_channel/</link>
      <pubDate>Mon, 13 Jan 2020 18:42:22 +0000</pubDate>
      
      <guid>https://nercoeus.github.io/post/go%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB_channel/</guid>
      <description>&lt;p&gt;  最近代码中出现了一个十分诡异的 bug,找了半天才发现原来是因为 channel 的使用不当所导的.channel 有一个特性是读一个有缓冲区且已关闭的 channel 时,会一直返回默认值.可能是 0,&amp;quot;&amp;quot;,或 nil,因为我使用了一个 for{select &amp;lt;-message}直接导致程序无限触发.要想更好的使用 channel 我们需要了解它内部的实现原理,下面就一起看看 channel 的实现.因为网上关于 channel 的文章十分之多,所以这里主要做的还是个人学习总结的为主.
  channel 是 golng 中十分重要的一个特性.认识 go 的开始就会了解到它的设计哲学, go 的设计哲学基于 CSP 并发模型,其便是通过 channel 来实现这一模型的.除了 channel,goroutine 也是整个设计中重要的组成部分.在 go 中不光可以使用 Mutex 等锁来进行同步,还可以使用 channel 来进行消息流控制的同步操作.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;</description>
    </item>
    
  </channel>
</rss>
